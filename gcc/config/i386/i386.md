;; Machine description for o386 (obfuscated i386 backend)
;; Copyright (C) 2014 Free Software Foundation, Inc.
;; Contributed by David Guillen Fandos <david@davidgf.net>

;; This file is part of GCC.

;; GCC is free software; you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published
;; by the Free Software Foundation; either version 3, or (at your
;; option) any later version.

;; GCC is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
;; License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

;; -------------------------------------------------------------------------
;; i386 specific constraints, predicates and attributes
;; -------------------------------------------------------------------------

(include "constraints.md")
(include "predicates.md")

(define_constants [
  (O386_ESP         7)
  (O386_EFLAGS     10)
])

; We don't really much care about instruction length nor optimizations by now
(define_attr "length" "" (const_int 1))

;; -------------------------------------------------------------------------
;; nop instruction
;; -------------------------------------------------------------------------

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop")

;; Arithmetic & logical instructions do modify flags register, therefore 
;; we must clobber them.
;; In general we support register as destination and any operand as source,
;; others like shifts use implicit registers.

;; -------------------------------------------------------------------------
;; Arithmetic instructions
;; -------------------------------------------------------------------------

(define_insn "addsi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (plus:SI
             (match_operand:SI  1 "register_operand" "0")
             (match_operand:SI  2 "general_operand"  "rCm")
        )
   )
   (clobber (reg:CC O386_EFLAGS))
  ]
  ""
  "addl %2, %0"
)


(define_insn "subsi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (minus:SI
             (match_operand:SI  1 "register_operand" "0")
             (match_operand:SI  2 "general_operand"  "rCm")
        )
   )
   (clobber (reg:CC O386_EFLAGS))
  ]
  ""
  "subl %2, %0"
)

(define_insn "mulsi3"
  [(set (match_operand:SI 0 "register_operand" "=a")
        (mult:SI
             (match_operand:SI  1 "register_operand" "0")
             (match_operand:SI  2 "general_operand"  "rm")
        )
   )
   (clobber (reg:CC O386_EFLAGS))
  ]
  ""
  "mull %2"
)

;; -------------------------------------------------------------------------
;; Logical operators
;; -------------------------------------------------------------------------

(define_insn "andsi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (and:SI
             (match_operand:SI  1 "register_operand" "0")
             (match_operand:SI  2 "general_operand"  "rCm")
        )
   )
   (clobber (reg:CC O386_EFLAGS))
  ]
  ""
  "andl %2, %0"
)

(define_insn "xorsi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (xor:SI
             (match_operand:SI  1 "register_operand" "0")
             (match_operand:SI  2 "general_operand"  "rCm")
        )
   )
   (clobber (reg:CC O386_EFLAGS))
  ]
  ""
  "@
  xorl %2, %0")

(define_insn "iorsi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (ior:SI
             (match_operand:SI  1 "register_operand" "0")
             (match_operand:SI  2 "general_operand"  "rCm")
        )
   )
   (clobber (reg:CC O386_EFLAGS))
  ]
  ""
  "orl %2, %0"
)

;; -------------------------------------------------------------------------
;; Shifters
;; -------------------------------------------------------------------------

; Left shift (arith/logic)
(define_insn "ashlsi3"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rm")
        (ashift:SI
             (match_operand:SI  1 "register_operand" "0")
             (match_operand:SI  2 "nonmemory_operand" "cU")
        )
   )
   (clobber (reg:CC O386_EFLAGS))
  ]
  ""
{
  return "shll   %b2,  %0";
}
)


; Right shift arithmetic
(define_insn "ashrsi3"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rm")
        (ashiftrt:SI
             (match_operand:SI  1 "register_operand" "0")
             (match_operand:SI  2 "nonmemory_operand" "cU")
        )
   )
   (clobber (reg:CC O386_EFLAGS))
  ]
""
{
  return "sarl   %b2,  %0";
})


; Right shift logical
(define_insn "lshrsi3"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=rm")
        (lshiftrt:SI
             (match_operand:SI  1 "register_operand" "0")
             (match_operand:SI  2 "nonmemory_operand" "cU")
        )
   )
   (clobber (reg:CC O386_EFLAGS))
  ]
  ""
{
  return "shrl   %b2,  %0";
})

;; -------------------------------------------------------------------------
;; Mov patterns 
;; -------------------------------------------------------------------------

(define_mode_iterator AMODE [QI HI SI])

; General move expand. Avoids mem to mem move
(define_expand "mov<mode>"
  [(set (match_operand:AMODE 0 "general_operand" "")
        (match_operand:AMODE 1 "general_operand" ""))]
   ""
{
  if (MEM_P (operands[0]))
    operands[1] = force_reg (<MODE>mode, operands[1]);
  emit_insn (gen_rtx_SET (<MODE>mode, operands[0], operands[1]));
  
  DONE;
})

; 32 bit move. No special restrictions apply
(define_insn "*movsi"
  [(set  (match_operand:SI 0 "general_operand" "=r, m"  )
         (match_operand:SI 1 "general_operand" "rmi,ri" )
  )]
  "(nonmemory_operand (operands[0], SImode) || nonmemory_operand (operands[1], SImode))"
{
  return "movl %1, %0";
}
)

; 16 bit move.
; Mem to reg uses zero extension
; Reg to Mem not restricted to any reg
; Reg/Imm to Reg uses long mode
(define_insn "*movhi"
  [(set  (match_operand:HI 0 "general_operand" "=r, m, r" )
         (match_operand:HI 1 "general_operand" "m,  r, rC" )
  )]
  ""
  "@
  movw   %1, %w0
  movw   %w1, %0
  movl   %1, %0"
)


; 8 bit move.
; Mem to reg uses zero extension
; Reg to mem uses a store (restricted to ABCD regs)
; Reg/Imm to Reg uses full-sized regs
(define_insn "*movqi"
  [(set  (match_operand:QI 0 "general_operand" "=r, m,    r"  )
         (match_operand:QI 1 "general_operand" "m,  abcd, rC" )
  )]
  ""
  "@
  movzbl %1, %0
  movb   %b1, %0
  movl   %1, %0"
)


;; Push a register onto the stack
(define_insn "movsi_push"
  [(set (mem:SI (pre_dec:SI (reg:SI O386_ESP)))
  	(match_operand:SI 0 "register_operand" ""))]
  ""
  "pushl   %0")

;; Pop a register from the stack
(define_insn "movsi_pop"
  [(set (match_operand:SI 0 "register_operand" "")
  	(mem:SI (post_inc:SI (reg:SI O386_ESP))))]
  ""
  "popl    %0"
)


;; -------------------------------------------------------------------------
;; Jumps and branches
;; -------------------------------------------------------------------------

(define_insn "indirect_jump"
  [(set (pc) (match_operand:SI 0 "general_operand" ""))]
  ""
  "jmp    %P0"
)

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "jmp   %P0"
)


;; -------------------------------------------------------------------------
;; Function calls
;; -------------------------------------------------------------------------

(define_expand "call"
  [(call (match_operand:SI 0 "memory_operand" "" )
         (match_operand    1 "general_operand" "")
  )]
  ""
{
  gcc_assert (MEM_P (operands[0]));
})

(define_insn "*call"
  [(call (mem:SI (match_operand:SI 0 "general_operand" "rCm"))
         (match_operand    1 "" ""))]
  ""
  "@
   call %P0"
)

(define_expand "call_value"
  [(set (match_operand 0 "" "")
        (call (match_operand:SI 1 "memory_operand" "")
              (match_operand 2 "" "")))]
  ""
{
  gcc_assert (MEM_P (operands[1]));
})

; FIXME: Should we enforce ret value @ eax?
(define_insn "*call_value"
  [(set (match_operand 0 "register_operand" "=r")
        (call (mem:SI (match_operand:SI 1 "general_operand" "rCm"))
              (match_operand 2 "" "")))]
  ""
  "call %P1"
)


(define_insn "returner"
  [(return)]
  "reload_completed"
  "ret"
)

;; -------------------------------------------------------------------------
;; Prologue & Epilogue
;; -------------------------------------------------------------------------

(define_expand "prologue"
  [(clobber (const_int 0))]
  ""
  "
{
  o386_expand_prologue ();
  DONE;
}
")

(define_expand "epilogue"
  [(return)]
  ""
  "
{
  o386_expand_epilogue ();
  DONE;
}
")



;; -------------------------------------------------------------------------
;; Set EFLAGS using various comparisons
;; -------------------------------------------------------------------------

(define_expand "cbranchsi4"
  [(set (reg:CC O386_EFLAGS)
        (compare:CC (match_operand:SI 1 "general_operand" "")
                    (match_operand:SI 2 "general_operand" "")
        )
   )
  (set (pc) (if_then_else
             (match_operator 0 "ordered_comparison_operator" [(reg:CC O386_EFLAGS) (const_int 0)])
             (label_ref (match_operand 3 "" ""))
             (pc)
            )
  )]
  ""
{
  if (MEM_P (operands[1]) && MEM_P (operands[2]))
    operands[1] = force_reg (SImode, operands[1]);
  o386_expand_branch (GET_CODE (operands[0]), operands[1], operands[2], operands[3]);
  DONE;
})

(define_insn "*reg_compare"
  [(set (reg:CC O386_EFLAGS)
        (compare:CC (match_operand:SI 0 "general_operand" "rm,rm ")
                    (match_operand:SI 1 "general_operand" "r, C")
        )
  )
  ]
 ""
 "cmpl %1, %0"
)


;;              (cond (reg:CC O386_EFLAGS) (const_int 0))
;;(define_code_iterator cond [ne eq lt ltu gt gtu ge le geu leu])

; Actual conditional jump
(define_insn "*jump_insn"
  [(set (pc) (if_then_else
              (match_operator 0 "ordered_comparison_operator" [(reg:CC O386_EFLAGS) (const_int 0)])
              (label_ref (match_operand 1 "" ""))
              (pc)
             )
   )]
  ""
{
  return o386_generate_cond_jump(operands[0]);
}
)



; Expand branch in test + branch
;(define_expand "compare_and_branch"
;  [(set (reg:CC O386_EFLAGS)
;        (compare:CC (match_operand:SI 1 "nonmemory_operand" "")
;                    (match_operand:SI 2 "general_operand" "")
;         )
;    )
;  (set (pc) (if_then_else
;             (match_operator 0 "ordered_comparison_operator" [(reg:CC O386_EFLAGS) (const_int 0)])
;             (label_ref (match_operand 3 "" ""))
;             (pc)
;            )
;  )]
;  ""
;{
;  //emit_insn (gen_cregtest (operands[1],operands[2]));
;  //emit_insn (gen_cbranch  (operands[0],operands[3]));
;  return "test %1, %2";
;})

; This is compare, writes EFLAGS using test operation
;(define_insn "cregtest"
;  [(set (reg:CC O386_EFLAGS)
;        (compare:CC (match_operand:SI 0 "nonmemory_operand" "")
;                    (match_operand:SI 1 "general_operand" "")))]
;  ""
;  "test %0, %1"
;)

; Actual conditional jump
;(define_insn "cbranch"
;  [(set (pc) (if_then_else
;              (match_operator 0 "ordered_comparison_operator" [(reg:CC O386_EFLAGS) (const_int 0)])
;              (label_ref (match_operand 1 "" ""))
;              (pc)
;             )
;   )]
;  ""
;  "condjump %P1"
;)

